import type * as AST from "./types/ast.ts";

// TODO: Surely there's a better way to do this...
// https://github.com/flint-fyi/flint/issues/1295

export interface TypeScriptNodesByName {
	AnyKeyword: AST.AnyKeyword;
	ArrayBindingPattern: AST.ArrayBindingPattern;
	ArrayLiteralExpression: AST.ArrayLiteralExpression;
	ArrayType: AST.ArrayTypeNode;
	ArrowFunction: AST.ArrowFunction;
	AsExpression: AST.AsExpression;
	AwaitExpression: AST.AwaitExpression;
	BigIntKeyword: AST.BigIntKeyword;
	BigIntLiteral: AST.BigIntLiteral;
	BinaryExpression: AST.BinaryExpression;
	BindingElement: AST.BindingElement;
	Block: AST.Block;
	BooleanKeyword: AST.BooleanKeyword;
	BreakStatement: AST.BreakStatement;
	CallExpression: AST.CallExpression;
	CallSignature: AST.CallSignatureDeclaration;
	CaseBlock: AST.CaseBlock;
	CaseClause: AST.CaseClause;
	CatchClause: AST.CatchClause;
	ClassDeclaration: AST.ClassDeclaration;
	ClassExpression: AST.ClassExpression;
	ClassStaticBlockDeclaration: AST.ClassStaticBlockDeclaration;
	CommaListExpression: AST.CommaListExpression;
	ComputedPropertyName: AST.ComputedPropertyName;
	ConditionalExpression: AST.ConditionalExpression;
	ConditionalType: AST.ConditionalTypeNode;
	Constructor: AST.ConstructorDeclaration;
	ConstructorType: AST.ConstructorTypeNode;
	ConstructSignature: AST.ConstructSignatureDeclaration;
	ContinueStatement: AST.ContinueStatement;
	DebuggerStatement: AST.DebuggerStatement;
	Decorator: AST.Decorator;
	DefaultClause: AST.DefaultClause;
	DeleteExpression: AST.DeleteExpression;
	DoStatement: AST.DoStatement;
	ElementAccessExpression: AST.ElementAccessExpression;
	EmptyStatement: AST.EmptyStatement;
	EnumDeclaration: AST.EnumDeclaration;
	EnumMember: AST.EnumMember;
	ExportAssignment: AST.ExportAssignment;
	ExportDeclaration: AST.ExportDeclaration;
	ExportSpecifier: AST.ExportSpecifier;
	ExpressionStatement: AST.ExpressionStatement;
	ExpressionWithTypeArguments: AST.ExpressionWithTypeArguments;
	ExternalModuleReference: AST.ExternalModuleReference;
	FalseKeyword: AST.FalseLiteral;
	ForInStatement: AST.ForInStatement;
	ForOfStatement: AST.ForOfStatement;
	ForStatement: AST.ForStatement;
	FunctionDeclaration: AST.FunctionDeclaration;
	FunctionExpression: AST.FunctionExpression;
	FunctionType: AST.FunctionTypeNode;
	GetAccessor: AST.GetAccessorDeclaration;
	HeritageClause: AST.HeritageClause;
	Identifier: AST.Identifier;
	IfStatement: AST.IfStatement;
	ImportAttribute: AST.ImportAttribute;
	ImportAttributes: AST.ImportAttributes;
	ImportClause: AST.ImportClause;
	ImportDeclaration: AST.ImportDeclaration;
	ImportEqualsDeclaration: AST.ImportEqualsDeclaration;
	ImportKeyword: AST.ImportExpression;
	ImportSpecifier: AST.ImportSpecifier;
	ImportType: AST.ImportTypeNode;
	IndexedAccessType: AST.IndexedAccessTypeNode;
	IndexSignature: AST.IndexSignatureDeclaration;
	InferType: AST.InferTypeNode;
	InterfaceDeclaration: AST.InterfaceDeclaration;
	IntersectionType: AST.IntersectionTypeNode;
	IntrinsicKeyword: AST.IntrinsicKeyword;
	JSDocAllType: AST.JSDocAllType;
	JSDocFunctionType: AST.JSDocFunctionType;
	JSDocLink: AST.JSDocLink;
	JSDocLinkCode: AST.JSDocLinkCode;
	JSDocLinkPlain: AST.JSDocLinkPlain;
	JSDocMemberName: AST.JSDocMemberName;
	JSDocNamepathType: AST.JSDocNamepathType;
	JSDocNonNullableType: AST.JSDocNonNullableType;
	JSDocNullableType: AST.JSDocNullableType;
	JSDocOptionalType: AST.JSDocOptionalType;
	JSDocParameterTag: AST.JSDocParameterTag;
	JSDocPropertyTag: AST.JSDocPropertyTag;
	JSDocReturnTag: AST.JSDocReturnTag;
	JSDocSignature: AST.JSDocSignature;
	JSDocTemplateTag: AST.JSDocTemplateTag;
	JSDocText: AST.JSDocText;
	JSDocTypeExpression: AST.JSDocTypeExpression;
	JSDocTypeLiteral: AST.JSDocTypeLiteral;
	JSDocUnknownType: AST.JSDocUnknownType;
	JSDocVariadicType: AST.JSDocVariadicType;
	JsxAttribute: AST.JsxAttribute;
	JsxAttributes: AST.JsxAttributes;
	JsxClosingElement: AST.JsxClosingElement;
	JsxClosingFragment: AST.JsxClosingFragment;
	JsxElement: AST.JsxElement;
	JsxExpression: AST.JsxExpression;
	JsxFragment: AST.JsxFragment;
	JsxNamespacedName: AST.JsxNamespacedName;
	JsxOpeningElement: AST.JsxOpeningElement;
	JsxOpeningFragment: AST.JsxOpeningFragment;
	JsxSelfClosingElement: AST.JsxSelfClosingElement;
	JsxSpreadAttribute: AST.JsxSpreadAttribute;
	JsxText: AST.JsxText;
	LabeledStatement: AST.LabeledStatement;
	LiteralType: AST.LiteralTypeNode;
	MappedType: AST.MappedTypeNode;
	MetaProperty: AST.MetaProperty;
	MethodDeclaration: AST.MethodDeclaration;
	MethodSignature: AST.MethodSignature;
	MissingDeclaration: AST.MissingDeclaration;
	ModuleBlock: AST.ModuleBlock;
	ModuleDeclaration: AST.ModuleDeclaration;
	NamedExports: AST.NamedExports;
	NamedImports: AST.NamedImports;
	NamedTupleMember: AST.NamedTupleMember;
	NamespaceExport: AST.NamespaceExport;
	NamespaceExportDeclaration: AST.NamespaceExportDeclaration;
	NamespaceImport: AST.NamespaceImport;
	NeverKeyword: AST.NeverKeyword;
	NewExpression: AST.NewExpression;
	NonNullExpression: AST.NonNullExpression;
	NoSubstitutionTemplateLiteral: AST.NoSubstitutionTemplateLiteral;
	NotEmittedStatement: AST.NotEmittedStatement;
	NotEmittedTypeElement: AST.NotEmittedTypeElement;
	NullKeyword: AST.NullLiteral;
	NumberKeyword: AST.NumberKeyword;
	NumericLiteral: AST.NumericLiteral;
	ObjectBindingPattern: AST.ObjectBindingPattern;
	ObjectKeyword: AST.ObjectKeyword;
	ObjectLiteralExpression: AST.ObjectLiteralExpression;
	OmittedExpression: AST.OmittedExpression;
	OptionalType: AST.OptionalTypeNode;
	Parameter: AST.ParameterDeclaration;
	ParenthesizedExpression: AST.ParenthesizedExpression;
	ParenthesizedType: AST.ParenthesizedTypeNode;
	PartiallyEmittedExpression: AST.PartiallyEmittedExpression;
	PostfixUnaryExpression: AST.PostfixUnaryExpression;
	PrefixUnaryExpression: AST.PrefixUnaryExpression;
	PrivateIdentifier: AST.PrivateIdentifier;
	PropertyAccessExpression: AST.PropertyAccessExpression;
	PropertyAssignment: AST.PropertyAssignment;
	PropertyDeclaration: AST.PropertyDeclaration;
	PropertySignature: AST.PropertySignature;
	QualifiedName: AST.QualifiedName;
	RegularExpressionLiteral: AST.RegularExpressionLiteral;
	RestType: AST.RestTypeNode;
	ReturnStatement: AST.ReturnStatement;
	SatisfiesExpression: AST.SatisfiesExpression;
	SemicolonClassElement: AST.SemicolonClassElement;
	SetAccessor: AST.SetAccessorDeclaration;
	ShorthandPropertyAssignment: AST.ShorthandPropertyAssignment;
	SourceFile: AST.SourceFile;
	SpreadAssignment: AST.SpreadAssignment;
	SpreadElement: AST.SpreadElement;
	StringKeyword: AST.StringKeyword;
	StringLiteral: AST.StringLiteral;
	SuperKeyword: AST.SuperExpression;
	SwitchStatement: AST.SwitchStatement;
	SymbolKeyword: AST.SymbolKeyword;
	SyntheticExpression: AST.SyntheticExpression;
	TaggedTemplateExpression: AST.TaggedTemplateExpression;
	TemplateExpression: AST.TemplateExpression;
	TemplateHead: AST.TemplateHead;
	TemplateLiteralType: AST.TemplateLiteralTypeNode;
	TemplateLiteralTypeSpan: AST.TemplateLiteralTypeSpan;
	TemplateMiddle: AST.TemplateMiddle;
	TemplateSpan: AST.TemplateSpan;
	TemplateTail: AST.TemplateTail;
	ThisKeyword: AST.ThisExpression;
	ThisType: AST.ThisTypeNode;
	ThrowStatement: AST.ThrowStatement;
	TrueKeyword: AST.TrueLiteral;
	TryStatement: AST.TryStatement;
	TupleType: AST.TupleTypeNode;
	TypeAliasDeclaration: AST.TypeAliasDeclaration;
	TypeAssertionExpression: AST.TypeAssertion;
	TypeLiteral: AST.TypeLiteralNode;
	TypeOfExpression: AST.TypeOfExpression;
	TypeOperator: AST.TypeOperatorNode;
	TypeParameter: AST.TypeParameterDeclaration;
	TypePredicate: AST.TypePredicateNode;
	TypeQuery: AST.TypeQueryNode;
	TypeReference: AST.TypeReferenceNode;
	UndefinedKeyword: AST.UndefinedKeyword;
	UnionType: AST.UnionTypeNode;
	UnknownKeyword: AST.UnknownKeyword;
	VariableDeclaration: AST.VariableDeclaration;
	VariableDeclarationList: AST.VariableDeclarationList;
	VariableStatement: AST.VariableStatement;
	VoidExpression: AST.VoidExpression;
	VoidKeyword: AST.VoidKeyword;
	WhileStatement: AST.WhileStatement;
	WithStatement: AST.WithStatement;
	YieldExpression: AST.YieldExpression;
}
